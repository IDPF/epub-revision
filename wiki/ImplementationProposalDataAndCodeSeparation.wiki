#summary Proposed solution for separation of data and code

= Introduction =

In many cases an interactive presentation can be thought of some sort of a "widget" that presents some data type. For instance a chess game may be recorded using standard chess move notation and presented as an animation. A slideshow can be recorded as a list of images and played inside a special widget. Widgets many be developed, tested and shared between EPUB authors, who can use them without need to code.

Inline widget portion of this proposal addresses issue I-3 and provides interoperable scripting for paginated views.

= Details =

Two types of widgets are proposed. We can choose to use only one type or both of them.

In both cases a set of custom media types is bound with a particular widget implementation file. A widget is instanciated using standard object tag that references a resource with a custom media type:

{{{
<object src="game.chess" type="application/vnd.acme.chess-game">
  <!-- fallback for no scripting case -->
</object>
}}}

In paginated contexts widget instances may overflow (if styled without psiibility of small display surface in mind), but should not, in general, be duplicated across pages. If they are duplicated, it should be done in a way that reuses the same widget instance in both cases.

Binding of a media type to a widget implementation is defined in OPF file using a new mediaType element (probably placed in a new section, e.g. mediaDef):

{{{
<mediaType type="application/vnd.acme.chess-game" handler="impl-resource-id"/>
}}}

impl-resource-id is an id of the resource that implements the widget (see below).

mediaType element can also be used to supply other information about custom media type, such as schema, etc.

== Scoped widgets ==

This is a simpler and more secure, but also more limited and more resource intensive type. Widget is implemented as an application/xhtml+xml file with embedded scripting that is instanciated as if it were directly referenced from the object tag, but with URL parameters (stuff after '?' in URL):
 * src - URL to the resource that is being displayed
 * type - resource media type

Object tag parameters (from param tags) if any are also given as URL parameters.

This type of widget can be embedded both in resources that allow and don't allow scripting.

== Inline widgets ==

Inline widget is more complex, but is much more flexible. It is implemented as application/ecmascript file. The script is executed directly in the referencing resource context, so inline widgets can only be used inside scriptable resources.

Script that implements the widget should create an "implementation" object and assign it to a variable named widgetImpl. In should not alter any other variables or change any object state in any way. Reading System should save the value of widgetImpl variable and restore it to its original state after widget script is executed. When a new object tag with a media type that the widget can handle is encountered, Reading System will call bind method on the implementation object with the object element as a parameter. 

After binding the widget implementation to an element, Reading System can also optionally call setVisibility method on the implementation with two parameters: object element and a flag indication if the page that holds the object became visible (true) or hidden (false).

Widget logic can then manipulate the DOM, in particular, children of the object tag to create custom visual appearance, register for events, etc. It can also add custom properties or methods to the object tag. Multiple widgets thus can communicate with each other by finding their peers using regular getElementById method.